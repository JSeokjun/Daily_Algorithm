# H, W, N, M = map(int, input().split(" "))

# w_cnt = 0
# pos = 0
# idx = 1

# while pos < W:
#     if idx % 2 == 1:
#         w_cnt += 1
#         pos += 1
#     else:
#         pos += M

#     idx += 1

# h_cnt = 0
# pos = 0
# idx = 1

# while pos < H:
#     if idx % 2 == 1:
#         h_cnt += 1
#         pos += 1
#     else:
#         pos += N

#     idx += 1

# print(w_cnt * h_cnt)

# 코드 리뷰
# 이 코드는 격자 패턴에서 특정 위치에 있는 요소의 개수를 계산하는 것으로 보입니다.

# 장점
# 코드가 간결하고 이해하기 쉽습니다.
# 변수명이 의미를 잘 전달합니다 (w_cnt, h_cnt, pos 등).
# 두 개의 유사한 루프를 사용하여 가로와 세로 방향의 계산을 분리했습니다.

# 개선 가능한 부분
# 입력 처리: input().split(" ") 대신 input().split()을 사용해도 됩니다. 공백 문자를 명시적으로 지정하지 않아도 기본적으로 모든 공백 문자를 기준으로 분리합니다.
# 알고리즘 최적화: 현재 코드는 반복문을 통해 하나씩 계산하고 있지만, 수학적 공식을 사용하면 더 효율적으로 계산할 수 있습니다.
# 가로 방향: (W + M) // (M + 1)
# 세로 방향: (H + N) // (N + 1)
# 변수 재사용: 두 번째 루프에서 pos와 idx 변수를 재사용하고 있는데, 새로운 변수명을 사용하면 코드의 가독성이 향상됩니다.

# 개선된 코드 제안
H, W, N, M = map(int, input().split())
w_cnt = (W - 1) // (M + 1) + 1
h_cnt = (H - 1) // (N + 1) + 1
print(w_cnt * h_cnt)

# 이 개선된 코드는 반복문 없이 수학적 공식을 사용하여 결과를 계산합니다. 이렇게 하면 코드가 더 간결해지고 실행 속도도 빨라집니다.

# 이전 코드는 반복문을 사용하여 격자 패턴에서 특정 위치에 있는 요소의 개수를 계산합니다:
# 가로 방향(w_cnt)의 경우:
# 첫 번째 위치(idx가 1일 때)에 요소를 놓고
# 그 다음에는 M칸을 건너뛰고(idx가 2일 때)
# 그 다음에는 다시 요소를 놓고(idx가 3일 때)
# 이런 식으로 반복합니다.
# 세로 방향(h_cnt)의 경우도 마찬가지로:
# 첫 번째 위치에 요소를 놓고
# N칸을 건너뛰고
# 다시 요소를 놓는 패턴을 반복합니다.

# 수학적 공식을 사용한 최적화
# 이 패턴은 수학적 공식으로 표현할 수 있습니다:
# 가로 방향(W)의 요소 개수 계산
# 첫 번째 요소는 항상 위치 0에 놓입니다.
# 그 다음 요소는 위치 (0 + 1 + M)에 놓입니다. (1칸 이동 후 M칸 건너뛰기)
# 그 다음은 위치 (0 + 1 + M + 1 + M)에 놓입니다.
# 이를 일반화하면: 요소의 위치는 k(M+1)에 놓입니다. (k는 0부터 시작하는 정수)
# 따라서 가로 방향의 요소 개수는 다음과 같이 계산할 수 있습니다:
# 마지막 요소의 위치는 W-1 이하여야 합니다.
# k(M+1) ≤ W-1
# k ≤ (W-1)/(M+1)
# k의 최대값은 (W-1)/(M+1)의 정수 부분입니다.
# 따라서 요소의 개수는 ⌊(W-1)/(M+1)⌋ + 1 입니다. (0부터 시작하므로 +1)
# 파이썬에서는 이를 (W-1) // (M+1) + 1로 표현할 수 있습니다.
# 세로 방향(H)의 요소 개수 계산
# 마찬가지 방법으로, 세로 방향의 요소 개수는 (H-1) // (N+1) + 1로 계산할 수 있습니다.

# 최적화의 이점
# 1. 시간 복잡도 개선: 반복문을 사용하면 O(W) 또는 O(H)의 시간 복잡도를 가지지만, 수학적 공식을 사용하면 O(1)의 시간 복잡도를 가집니다.
# 2. 코드 간결성: 수학적 공식을 사용하면 코드가 더 짧고 간결해집니다.
# 3. 정확성: 큰 입력값에 대해서도 정확한 결과를 빠르게 계산할 수 있습니다.
# 이러한 최적화는 특히 W와 H가 매우 큰 경우에 성능 차이가 두드러집니다.